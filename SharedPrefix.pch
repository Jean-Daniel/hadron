/*
 *  SharedPrefix.h
 *  WonderBox
 *
 *  Created by Jean-Daniel Dupas.
 *  Copyright (c) 2004 - 2008 Jean-Daniel Dupas. All rights reserved.
 */
/*!
@header SharedPrefix
 @abstract WonderBox Prefix Header.
 @discussion A bunch of macros and inline functions usefull everywhere.
 Some of them are affected by the DEBUG precompiler macros.
 It can safely be include in C and Obj-C files.
*/

#if !defined(__SHARED_PREFIX_H)
#define __SHARED_PREFIX_H 1

/* allows compilation of some file without dependences on Foundation */
#if !defined(WB_NO_OBJC) && (defined(__OBJC__) || defined(__OBJC2__))
  #define __WB_OBJC__ 1
#endif

#include <tgmath.h>

#if defined(__WB_OBJC__)
#import <Cocoa/Cocoa.h>
#else
#include <CoreServices/CoreServices.h>
#endif

#if !defined(MAC_OS_X_VERSION_10_5)
  #define MAC_OS_X_VERSION_10_5 1050
#endif

#if !defined(MAC_OS_X_VERSION_10_6)
#define MAC_OS_X_VERSION_10_6 1060
#endif

/* Wonderbox build support */
#if defined(WONDERBOX_FRAMEWORK)
  #if !defined(WONDERBOX_NAME)
    #define WONDERBOX_NAME WonderBox
  #endif
  #define WBHEADER(header) <WONDERBOX_NAME/header>
#else
  #define WBHEADER(header) #header
#endif

/* Use to avoid class name conflict when statically linking WonderBox class */
#if !defined(WB_CLASS_PREFIX)
	#define WB_CLASS_PREFIX WB
#endif

// The magie of argument prescan !
#define __WBClass(prefix, class) prefix ## class
#define _WBClass(prefix, class) __WBClass(prefix, class)

#define __WBInternalClass(prefix, class) _ ## prefix ## class
#define _WBInternalClass(prefix, class) __WBInternalClass(prefix, class)

// Public macros
#define WBClass(class) __WBClass(WB_CLASS_PREFIX, class)
#define WBInternalClass(class) _WBInternalClass(WB_CLASS_PREFIX, class)

// Misc useful includes
#include <asl.h>
#include <libgen.h>
#include <libkern/OSAtomic.h>

#pragma mark Visibility Macros

#pragma mark Attributes

#if !defined(WB_VISIBLE)
  #define WB_VISIBLE __attribute__((visibility("default")))
#endif

#if !defined(WB_HIDDEN)
  #define WB_HIDDEN __attribute__((visibility("hidden")))
#endif

#if !defined(WB_EXTERN)
  #if defined(__cplusplus)
    #define WB_EXTERN extern "C" 
  #else
    #define WB_EXTERN extern
  #endif
#endif

#if !defined(WB_OBSOLETE)
  #define WB_OBSOLETE __attribute__((deprecated))
#endif

#if !defined(WB_REQUIRES_NIL_TERMINATION)
  #if defined(__APPLE_CC__) && (__APPLE_CC__ >= 5549)
    #define WB_REQUIRES_NIL_TERMINATION __attribute__((sentinel(0,1)))
  #else
    #define WB_REQUIRES_NIL_TERMINATION __attribute__((sentinel))
  #endif
#endif

#if !defined(WB_REQUIRED_ARGS)
  #define WB_REQUIRED_ARGS(idx, args...) __attribute__((nonnull(idx, ##args)))
#endif

#pragma mark Visibility
/*!
 @defined WB_PRIVATE
 @abstract Private extern symbol.
 */
/*!
 @defined WB_EXPORT
 @abstract Exported Wonderbox Function.
 @discussion If WONDERBOX_FRAMEWORK is not defined, WB_EXPORT is the same than WB_PRIVATE
 */
/*!
 @defined WB_PLUGIN_EXPORT
 @abstract Use for plugin entry point. Always export even if WONDERBOX_FRAMEWORK is not defined.
 */

#if defined(__cplusplus)
  #define __inline__ inline
#endif

#define WB_PRIVATE WB_EXTERN WB_HIDDEN
#define WB_PLUGIN_EXPORT WB_EXTERN WB_VISIBLE

#if defined(WONDERBOX_FRAMEWORK)
  #define WB_EXPORT WB_EXTERN WB_VISIBLE
#else
  #define WB_EXPORT WB_EXTERN WB_HIDDEN
#endif

/*!
 @defined WB_CLASS_EXPORT
 @abstract Public class. (64 bits only)
 @discussion If WONDERBOX_FRAMEWORK is not defined, WB_CLASS_EXPORT is the same than WB_CLASS_PRIVATE
 */
/*!
 @defined WB_CLASS_PRIVATE
 @abstract Internal class. (64 bits only)
 */
#if !defined(WB_CLASS_EXPORT)
  #if __LP64__
    #define WB_CLASS_PRIVATE WB_HIDDEN

    #if defined(WONDERBOX_FRAMEWORK)
      #define WB_CLASS_EXPORT WB_VISIBLE
    #else
      #define WB_CLASS_EXPORT WB_CLASS_PRIVATE      
    #endif
  #else
    #define WB_CLASS_EXPORT
    #define WB_CLASS_PRIVATE    
  #endif /* Framework && 64 bits runtime */
#endif

#if !defined(WB_INLINE)
  #if !defined(__NO_INLINE__)
    #define WB_INLINE static __inline__ __attribute__((always_inline))
  #else
    #define WB_INLINE static __inline__
  #endif /* No inline */
#endif

#pragma mark Clang

#ifndef __has_builtin         // Optional of course.
  #define __has_builtin(x) 0  // Compatibility with non-clang compilers.
#endif

#ifndef __has_feature         // Optional of course.
  #define __has_feature(x) 0  // Compatibility with non-clang compilers.
#endif

#ifndef UNUSED_IVAR
  #if __has_feature(attribute_objc_ivar_unused)
    #define UNUSED_IVAR __attribute__((unused))
  #else
    #define UNUSED_IVAR
  #endif
#endif

#ifndef NS_RETURNS_RETAINED
  #if __has_feature(attribute_ns_returns_retained)
    #define NS_RETURNS_RETAINED __attribute__((ns_returns_retained))
  #else
    #define NS_RETURNS_RETAINED
  #endif
#endif

#ifndef CF_RETURNS_RETAINED
  #if __has_feature(attribute_cf_returns_retained)
    #define CF_RETURNS_RETAINED __attribute__((cf_returns_retained))
  #else
    #define CF_RETURNS_RETAINED
  #endif
#endif

#pragma mark -
#pragma mark Leopard
#if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_5
  #if !__LP64__
    typedef int NSInteger;
    typedef unsigned int NSUInteger;

    typedef float CGFloat;
    #define CGFLOAT_MIN FLT_MIN
    #define CGFLOAT_MAX FLT_MAX
  #else
    #error 64 bits no supported for deployement version < MAC_OS_X_VERSION_10_5.
  #endif

  #define NSIntegerMax    LONG_MAX
  #define NSIntegerMin    LONG_MIN
  #define NSUIntegerMax   ULONG_MAX
#endif

/* Tiger only */
#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
  #define NSIntegerHashCallBacks NSIntHashCallBacks
  #define NSIntegerMapKeyCallBacks NSIntMapKeyCallBacks
  #define NSIntegerMapValueCallBacks NSIntMapValueCallBacks
#endif

/* Garbage collector (required Mac OS 10.5) */
#if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5
  #define WBMakeCollectable(ptr) NSMakeCollectable(ptr)
  #define WBAutoreleasePoolDrain(pool) [pool drain]
#else
  #define WBMakeCollectable(ptr) (id)ptr
  #define WBAutoreleasePoolDrain(pool) [pool release]
#endif

#define WBCFAutorelease(cftype) [WBMakeCollectable(cftype) autorelease]

#pragma mark -
#pragma mark Misc C Macros

#if !defined(XOR)
#define XOR(A, B)	({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); (__a || __b) && !(__a && __b); })
#endif

#if !defined(AVG)
#define AVG(A, B)	({ (A + B) / 2; })
#endif

// MARK: Math Macros
#if defined(__clang__) || defined(__cplusplus)
// Clang use a special attribute to make a function overloadable (like C++), 
// so we can merge C++ definitions with clang C definitions.

#if defined(__cplusplus)
  #define __WB_CLANG_TG_DECL(type) static inline type __attribute__((__always_inline__))
#else
  #define __WB_CLANG_TG_DECL(type) static __inline__ type __attribute__((__overloadable__, __always_inline__))
#endif

// Clang TG Math support
__WB_CLANG_TG_DECL(bool) __tg_fequal(float a, float b);
__WB_CLANG_TG_DECL(bool) __tg_fequal(double a, double b);
__WB_CLANG_TG_DECL(bool) __tg_fequal(long double a, long double b);

__WB_CLANG_TG_DECL(bool) __tg_fequal(float a, float b) { float delta = a - b; return (delta <= FLT_EPSILON && delta >= -FLT_EPSILON); }
__WB_CLANG_TG_DECL(bool) __tg_fequal(double a, double b) { double delta = a - b; return (delta <= DBL_EPSILON && delta >= -DBL_EPSILON); }
__WB_CLANG_TG_DECL(bool) __tg_fequal(long double a, long double b) { long double delta = a - b; return (delta <= LDBL_EPSILON && delta >= -LDBL_EPSILON); }

__WB_CLANG_TG_DECL(bool) __tg_fnotequal(float a, float b);
__WB_CLANG_TG_DECL(bool) __tg_fnotequal(double a, double b);
__WB_CLANG_TG_DECL(bool) __tg_fnotequal(long double a, long double b);

__WB_CLANG_TG_DECL(bool) __tg_fnotequal(float a, float b) { return !__tg_fequal(a, b); }
__WB_CLANG_TG_DECL(bool) __tg_fnotequal(double a, double b) { return !__tg_fequal(a, b); }
__WB_CLANG_TG_DECL(bool) __tg_fnotequal(long double a, long double b) { return !__tg_fequal(a, b); }

__WB_CLANG_TG_DECL(bool) __tg_fiszero(float f);
__WB_CLANG_TG_DECL(bool) __tg_fiszero(double f);
__WB_CLANG_TG_DECL(bool) __tg_fiszero(long double f);

__WB_CLANG_TG_DECL(bool) __tg_fiszero(float f) { return __tg_fequal(f, (float)0); }
__WB_CLANG_TG_DECL(bool) __tg_fiszero(double f) { return __tg_fequal(f, (double)0); }
__WB_CLANG_TG_DECL(bool) __tg_fiszero(long double f) { return __tg_fequal(f, (long double)0); }

__WB_CLANG_TG_DECL(bool) __tg_fnonzero(float f);
__WB_CLANG_TG_DECL(bool) __tg_fnonzero(double f);
__WB_CLANG_TG_DECL(bool) __tg_fnonzero(long double f);

__WB_CLANG_TG_DECL(bool) __tg_fnonzero(float f) { return !__tg_fiszero(f); }
__WB_CLANG_TG_DECL(bool) __tg_fnonzero(double f) { return !__tg_fiszero(f); }
__WB_CLANG_TG_DECL(bool) __tg_fnonzero(long double f) { return !__tg_fiszero(f); }

#if defined(__cplusplus)
  #define fiszero(__x)         __tg_fiszero(__x)
  #define fnonzero(__x)        __tg_fnonzero(__x)
  #define fequal(__x, __y)     __tg_fequal(__x, __y)
  #define fnotequal(__x, __y)  __tg_fnotequal(__x, __y)
#else
  #define fiszero(__x)         __tg_fiszero(__tg_promote1((__x))(__x))
  #define fnonzero(__x)        __tg_fnonzero(__tg_promote1((__x))(__x))
  #define fequal(__x, __y)     __tg_fequal(__tg_promote2((__x), (__y))(__x), __tg_promote2((__x), (__y))(__y))
  #define fnotequal(__x, __y)  __tg_fnotequal(__tg_promote2((__x), (__y))(__x), __tg_promote2((__x), (__y))(__y))
#endif

#undef __WB_CLANG_TG_DECL
#else
// GCC TG Math support
WB_INLINE bool __tg_fequalf(float a, float b) { float delta = a - b; return (delta <= FLT_EPSILON && delta >= -FLT_EPSILON); }
WB_INLINE bool __tg_fequal(double a, double b) { double delta = a - b; return (delta <= DBL_EPSILON && delta >= -DBL_EPSILON); }
WB_INLINE bool __tg_fequall(long double a, long double b) { long double delta = a - b; return (delta <= LDBL_EPSILON && delta >= -LDBL_EPSILON); }

WB_INLINE bool __tg_fnotequalf(float a, float b) { return !__tg_fequalf(a, b); }
WB_INLINE bool __tg_fnotequal(double a, double b) { return !__tg_fequal(a, b); }
WB_INLINE bool __tg_fnotequall(long double a, long double b) { return !__tg_fequall(a, b); }

WB_INLINE bool __tg_fiszerof(float f) { return __tg_fequalf(f, 0.f); }
WB_INLINE bool __tg_fiszero(double f) { return __tg_fequal(f, 0.); }
WB_INLINE bool __tg_fiszerol(long double f) { return __tg_fequall(f, 0.); }

WB_INLINE bool __tg_fnonzerof(float f) { return !__tg_fiszerof(f); }
WB_INLINE bool __tg_fnonzero(double f) { return !__tg_fiszero(f); }
WB_INLINE bool __tg_fnonzerol(long double f) { return !__tg_fiszerol(f); }

#define fiszero(x)        __TGMATH_REAL(x, __tg_fiszero)
#define fnonzero(x)       __TGMATH_REAL(x, __tg_fnonzero)
#define fequal(x, y)      __TGMATH_REAL_2(x, y, __tg_fequal)
#define fnotequal(x, y)   __TGMATH_REAL_2(x, y, __tg_fnotequal)

#endif // clang/gcc

#pragma mark Bitfields
/* Bit manipulation macros */
/* Bits are numbered from 31/63 on left to 0 on right */
/* May or may not work if you use them on bitfields in types other than NSUInteger, bitfields the full width of a NSUInteger, or anything else for which they were not designed. */
/* In the following, N1 and N2 specify an inclusive range N2..N1 with N1 >= N2 */
#if __LP64__
  #define WBBitfieldMask(N1, N2)	((((NSUInteger)~0UL) << (63UL - (N1) + (N2))) >> (63UL - N1))
#else
  #define WBBitfieldMask(N1, N2)	((((NSUInteger)~0UL) << (31UL - (N1) + (N2))) >> (31UL - N1))
#endif
#define WBBitfieldGetValue(V, N1, N2)	(((V) & WBBitfieldMask(N1, N2)) >> (N2))
#define WBBitfieldSetValue(V, N1, N2, X)	((V) = ((V) & ~WBBitfieldMask(N1, N2)) | (((X) << (N2)) & WBBitfieldMask(N1, N2)))
#define WBBitfieldMaxValue(N1, N2)	WBBitfieldGetValue(0xFFFFFFFFUL, (N1), (N2))

#define WBBitSet(V, N)  ((V) |= (1UL << (N)))
#define WBBitClear(V, N)  ((V) &= ~(1UL << (N)))
#define WBBitIsSet(V, N)  (((V) & (1UL << (N))) != 0)

/* Use to set a boolean value in a bitfield */
#define WBFlagSet(field, value)	do { field = ((value) != 0) ? 1 : 0; } while (0)
#define WBFlagTestAndSet(field, value) ({ bool __old = field; field = ((value) != 0) ? 1 : 0; __old; })

#pragma mark Logging

WB_INLINE
const char *__WBASLLevelString(int level) {
  switch (level) {
    case ASL_LEVEL_EMERG: return ASL_STRING_EMERG;
    case ASL_LEVEL_ALERT: return ASL_STRING_ALERT;
    case ASL_LEVEL_CRIT: return ASL_STRING_CRIT;
    case ASL_LEVEL_ERR: return ASL_STRING_ERR;
    case ASL_LEVEL_WARNING: return ASL_STRING_WARNING;
    case ASL_LEVEL_NOTICE: return ASL_STRING_NOTICE;
    case ASL_LEVEL_INFO: return ASL_STRING_INFO;
    case ASL_LEVEL_DEBUG: return ASL_STRING_DEBUG;
  }
  return "????";
}

#if DEBUG
// MARK: -
// MARK: =================== Debugging Configuration ===================

// Adding a static method here is not desired, but this is for debug build only.
// And we really don't want to use NSLog as it clutters the Console

#include <unistd.h>
#include <pthread.h>
#include <sys/time.h>

// .hack from CoreFoundation, see comment below
WB_EXTERN
void *vproc_swap_integer(void *, int, int64_t *, int64_t *);

static
void __WBLogPrintLinePrefix(FILE *f) {
  // This hacky call is from CoreFoundation. 
  // This is the way CoreFoundation (and so NSLog) determines if it should log in stderr
  // As we only use stderr (and not asl like CF does), we use this same hack to prevent duplicate
  // prefix in Console output when not running in Xcode (lauchd already append a prefix).
  // if it could be a pipe back to launchd, ignore
  int64_t val = 0;
  // assumes val is not written to on error
  vproc_swap_integer(NULL, 5 /* VPROC_GSK_IS_MANAGED */, NULL, &val);
  if (val) return;

  /* Print date first */
  char dtime[32];
  struct timeval nows;
  gettimeofday(&nows, NULL);
  
  struct tm now;
  localtime_r(&nows.tv_sec, &now);
  strftime(dtime, 32, "%F %T.", &now);
  fwrite(dtime, 1, strlen(dtime), f);
  
  fprintf(f, "%.3u %s[%u:%x] ", nows.tv_usec / 1000, getprogname(), getpid(), pthread_mach_thread_np(pthread_self()));
}

static __attribute__((unused))
void __WBLogPrintString(CFStringRef aString, bool eol, FILE *f) {
  // Print message
  const char *cstr = NULL;
  if (!aString) 
    cstr = "(null)";
  else
    cstr = CFStringGetCStringPtr(aString, kCFStringEncodingUTF8);
  
  if (cstr) {
    fwrite(cstr, 1, strlen(cstr), f);
  } else {
    // Fallback to slow path
    CFRange range = CFRangeMake(0, CFStringGetLength(aString));
    while (range.length > 0) {
      CFIndex length;
      uint8_t buffer[128];
      CFIndex done = CFStringGetBytes(aString, range, kCFStringEncodingUTF8, '?', false, buffer, 128, &length);
      if (done > 0) {
        fwrite(buffer, 1, done, stderr);
        range.location += done;
        range.length -= done;
      } else {
        // abort convertion
        range.length = 0;
      }
    }
  }
  if (eol)
    fwrite("\n", 1, 1, f);
}

#define DCLog(format, args...)  do { \
  __WBLogPrintLinePrefix(stderr); \
  fprintf(stderr, format "\n", ## args); \
} while (0)

#define DCLogv(format, args)  do { \
  __WBLogPrintLinePrefix(stderr); \
  vfprintf(stderr, format "\n", args); \
while (0)

#define WBCLog(client, msg, level, format, args...) do { \
  __WBLogPrintLinePrefix(stderr); \
  fprintf(stderr, "Log(%s): " format "\n", __WBASLLevelString(level), ## args); \
} while (0)

WB_INLINE
void WBCLogv(aslclient client, aslmsg msg, int level, const char *format, va_list args) {
  char *str = NULL;
  if (vasprintf(&str, format, args) >= 0 && str) {
    __WBLogPrintLinePrefix(stderr);
    fprintf(stderr, "Log(%s): %s\n", __WBASLLevelString(level), str);
    free(str);
  }
}

#define WBCTrace() do { \
  __WBLogPrintLinePrefix(stderr); \
  char *__file = strdup(__FILE__); \
  fprintf(stderr, "[%s:%li]: %s()\n", __file ? basename(__file) : "", (long)__LINE__, __PRETTY_FUNCTION__); \
  if (__file) free(__file); \
} while(0)

#define WBTrace() do { \
  __WBLogPrintLinePrefix(stderr); \
  char *__file = strdup(__FILE__); \
  fprintf(stderr, "[%s:%li]: %s\n", __file ? basename(__file) : "", (long)__LINE__, __PRETTY_FUNCTION__); \
  if (__file) free(__file); \
} while(0)

#if defined (__WB_OBJC__)
// MARK: ============= Objective-C =============
#define DLog(format, args...)   do { \
  CFStringRef __str = CFStringCreateWithFormat(kCFAllocatorDefault, NULL, (CFStringRef)format, ##args); \
  if (__str) { \
    __WBLogPrintLinePrefix(stderr); \
    __WBLogPrintString(__str, true, stderr); \
    CFRelease(__str); \
  } \
} while(0)

WB_INLINE 
void DLogv(NSString *format, va_list args) {
  CFStringRef __str = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, NULL, (CFStringRef)format, args);
  if (__str) {
    __WBLogPrintLinePrefix(stderr);
    __WBLogPrintString(__str, true, stderr);
    CFRelease(__str);
  }
}

WB_INLINE 
void WBLogv(aslclient client, aslmsg msg, int level, NSString *format, va_list args) {
  CFStringRef __str = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, NULL, (CFStringRef)format, args);
  if (__str) {
    __WBLogPrintLinePrefix(stderr);
    fprintf(stderr, "Log(%s): ", __WBASLLevelString(level));
    __WBLogPrintString(__str, true, stderr);
    CFRelease(__str);
  }
}

//WB_INLINE 
//void WBLog(aslclient client, aslmsg msg, int level, NSString *format, ...) { var_args and inline are incompatible
#define WBLog(client, msg, level, format, args...) do { \
  CFStringRef __str = CFStringCreateWithFormat(kCFAllocatorDefault, NULL, (CFStringRef)format, ##args); \
  if (__str) { \
    __WBLogPrintLinePrefix(stderr); \
    fprintf(stderr, "Log(%s): ", __WBASLLevelString(level)); \
    __WBLogPrintString(__str, true, stderr); \
    CFRelease(__str); \
  } \
} while (0)

/* Dynamic trace */
extern const char * class_getName(Class cls);
WB_INLINE
void __WBDTrace(id self, SEL _cmd, const char *filename, long line) {
  __WBLogPrintLinePrefix(stderr);
  char *__file = strdup(filename);
  fprintf(stderr, "[%s:%li]: %c[%s %s]\n", __file ? basename(__file) : "", line, self == (id)[self class] ? '+' : '-', class_getName([self class]), sel_getName(_cmd));
  if (__file) free(__file);
}

#define WBDTrace() __WBDTrace(self, _cmd, __FILE__, __LINE__)

// Property Accessor checking
#define WBProperty(propName)    NSStringFromSelector(@selector(propName))

#endif /* __WB_OBJC__ */

#else
// MARK: -
// MARK: =================== Release Configuration ===================

#define DCLog(format, args...) do {} while (0)
#define DCLogv(format, args) do {} while (0)

#define WBCLog(client, msg, level, format, args...) asl_log(client, msg, level, format, ## args)
WB_INLINE
void WBCLogv(aslclient client, aslmsg msg, int level, const char *format, va_list args) {
  asl_vlog(client, msg, level, format, args);
}

/*!
 @defined WBCTrace
 @abstract Print a string like: '[file:line]: function()'.
 @discussion This Macro does nothing when DEBUG is not defined
 */
#define WBCTrace() do {} while (0)

#if defined (__WB_OBJC__)
// MARK: ============= Objective-C =============
/*!
 @defined DLog
 @abstract Debug Log. This function is just a NSLog Wrapper that can enabled or disabled by the Precompiler.
 @discussion This Macro does nothing when DEBUG is not defined
 @param str A String like in NSLog.
 @param ... parameters.
 */
#define DLog(format, args...) do {} while (0)
#define DLogv(format, args) do {} while (0)

WB_INLINE
void WBLogv(aslclient client, aslmsg msg, int level, NSString *format, va_list args) {
  NSString *__str = [[NSString alloc] initWithFormat:format arguments:args];
  if (__str) {
    asl_log(client, msg, level, "%s", [__str UTF8String]);
    [__str release];
  }
}

//WB_INLINE 
//void WBLog(aslclient client, aslmsg msg, int level, NSString *format, ...) { var_args and inline are incompatible
#define WBLog(client, msg, level, format, args...) do { \
  NSString *__str = [[NSString alloc] initWithFormat:format, ##args]; \
  if (__str) { \
    asl_log(client, msg, level, "%s", [__str UTF8String]); \
    [__str release]; \
  } \
} while (0)

/*!
 @defined WBTrace
 @abstract Print a string like: '+/-[sender selector]'.
 @discussion This Macro does nothing when DEBUG is not defined
 */
#define WBTrace() do {} while (0)
#define WBDTrace() do {} while (0)

// Property Accessor checking
#define WBProperty(propName)    @#propName

#endif /* __WB_OBJC__ */

#endif


/* =================== Common =================== */
#define WBCLogWarning(format, args...) WBCLog(NULL, NULL, ASL_LEVEL_WARNING, format, ## args)
#define WBCLogError(format, args...) WBCLog(NULL, NULL, ASL_LEVEL_ERR, format, ## args)

#if defined (__WB_OBJC__)
#define WBLogWarning(format, args...) WBLog(NULL, NULL, ASL_LEVEL_WARNING, format, ## args)
#define WBLogError(format, args...) WBLog(NULL, NULL, ASL_LEVEL_ERR, format, ## args)
#endif

// Assert
#if DEBUG_ASSERT_PRODUCTION_CODE
  #define WBCAssert(assertion, message) do { } while (0)
#else
  #define WBCAssert(assertion, message) \
  do { \
    if (__builtin_expect(!(assertion), 0)) { \
      DEBUG_ASSERT_MESSAGE( \
        DEBUG_ASSERT_COMPONENT_NAME_STRING, \
        #assertion, 0, message, __FILE__, __LINE__, 0); \
    } \
  } while (0)
#endif /* DEBUG_ASSERT_PRODUCTION_CODE */

// WBCompileAssert
// WBCompileAssert is an assert that is meant to fire at compile time if you
// want to check things at compile instead of runtime. For example if you
// want to check that a wchar is 4 bytes instead of 2 you would use
// WBCompileAssert(sizeof(wchar_t) == 4, wchar_t_is_4_bytes_on_OS_X)
// Note that the second "arg" is not in quotes, and must be a valid processor
// symbol in it's own right (no spaces, punctuation etc).

// Wrapping this in an #ifndef allows external groups to define their own compile time assert scheme.
// We got this technique from here:
// http://unixjunkie.blogspot.com/2007/10/better-compile-time-asserts_29.html

#define _WBCompileAssertSymbolInner(line, msg) WBCOMPILEASSERT ## line ## __ ## msg
#define _WBCompileAssertSymbol(line, msg) _WBCompileAssertSymbolInner(line, msg)
#define WBCompileAssert(test, msg) \
    typedef char _WBCompileAssertSymbol(__LINE__, msg) [ ((test) ? 1 : -1) ]

#pragma mark -

WB_INLINE
void WBRelease(CFTypeRef aValue) { if (aValue) CFRelease(aValue); }

#pragma mark Objective-C Macros

#if defined (__WB_OBJC__)

#pragma mark Generic Macros

WB_INLINE __attribute__((__noreturn__))
void WBThrowExceptionWithInfov(NSString *name, NSDictionary *userInfo, NSString *fmt, va_list args)  {
  NSString *str = [[NSString alloc] initWithFormat:fmt arguments:args];
  @throw [NSException exceptionWithName:name reason:[str autorelease] userInfo:userInfo];
}

//WB_INLINE __attribute__((__noreturn__))
//void WBThrowExceptionWithInfo(NSString *name, NSDictionary *userInfo, NSString *fmt, ...)
#define WBThrowExceptionWithInfo(name, info, fmt, args...) do { \
  NSString *__str = [[NSString alloc] initWithFormat:fmt, ##args]; \
  @throw [NSException exceptionWithName:name reason:[__str autorelease] userInfo:info]; \
} while (0)

//WB_INLINE __attribute__((__noreturn__))
//void WBThrowException(NSString *name, NSString *fmt, ...)
#define WBThrowException(name, fmt, args...) WBThrowExceptionWithInfo(name, nil, fmt, ##args)

/*!
 @defined WBLogException
 @abstract Log an exception with the method where it occured.
 @discussion Use NSLog when DEBUG and asl in production.
 @param exception An id representing the Exception to log.
 */
#define WBLogException(exception) do { \
  char *__file = strdup(__FILE__); \
  WBLog(NULL, NULL, ASL_LEVEL_ERR, @"%@ caught in %s (%s:%li): %@", \
        [exception respondsToSelector:@selector(name)] ? [exception name] : @"Undefined Exception" , \
        __func__, __file ? basename(__file) : "", (long)__LINE__, exception); \
  if (__file) free(__file); \
} while(0)

/*!
 @defined WBCLogException
 @abstract Log an exception with the function where it occured.
 @discussion Use NSLog when DEBUG and asl in production.
 @param exception An id representing the Exception to log.
 */
#define WBCLogException(exception) do { \
  char *__file = strdup(__FILE__); \
  WBLog(NULL, NULL, ASL_LEVEL_ERR, @"%@ caught in %s() [%s:%li]: %@", \
        [exception respondsToSelector:@selector(name)] ? [exception name] : @"Undefined Exception" , \
        __func__, __file ? basename(__file) : "", (long)__LINE__, exception); \
  if (__file) free(__file); \
} while(0)

#pragma mark Assert
// we directly invoke the NSAssert handler so we can pass on the varargs
// (NSAssert doesn't have a macro we can use that takes varargs)
#if !defined(NS_BLOCK_ASSERTIONS)
#define WBAssert(condition, desc, args...) \
do { \
  if (__builtin_expect(!(condition), 0)) \
    [[NSAssertionHandler currentHandler] handleFailureInFunction:[NSString stringWithUTF8String:__func__] \
                                                            file:[NSString stringWithUTF8String:__FILE__ ] \
                                                      lineNumber:__LINE__ \
                                                     description:desc, ##args]; \
  } while(0)
#else // !defined(NS_BLOCK_ASSERTIONS)
  #define WBAssert(condition, ...) do { } while (0)
#endif // !defined(NS_BLOCK_ASSERTIONS)

#pragma mark Other Objective-C Macros
/* For safety we retain var before releasing ivar (ivar can contain the last reference on var). */
#define WBSetterRetain(ivar, var) _WBSetterRetain(&ivar, var)
WB_INLINE
BOOL _WBSetterRetain(id *ivar, id var) {
  if (*ivar != var) {
    [var retain];
    [*ivar release];
    *ivar = var;
    return YES;
  }
  return NO;
}

/* For safety we copy var before releasing ivar (ivar can contain the last reference on var). */
#define WBSetterCopy(ivar, var) _WBSetterCopyWithZone(&ivar, var, [self zone])
#define WBSetterCopyWithZone(ivar, var, aZone) _WBSetterCopyWithZone(&ivar, var, aZone)
WB_INLINE
BOOL _WBSetterCopyWithZone(id *ivar, id var, NSZone *aZone) {
  if (*ivar != var) {
    var = [var copyWithZone:aZone];
    [*ivar release];
    *ivar = var;
    return YES;
  }
  return NO;
}

#define WBSetterMutableCopy(ivar, var) _WBSetterMutableCopyWithZone(&ivar, var, [self zone])
#define WBSetterMutableCopyWithZone(ivar, var, aZone) _WBSetterMutableCopyWithZone(&ivar, var, aZone)
WB_INLINE
BOOL _WBSetterMutableCopyWithZone(id *ivar, id var, NSZone *aZone) {
  if (*ivar != var) {
    var = [var mutableCopyWithZone:aZone];
    [*ivar release];
    *ivar = var;
    return YES;
  }
  return NO;
}

// MARK: Atomic Variants
//extern id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic);
//extern void objc_copyStruct(void *dest, const void *src, ptrdiff_t size, BOOL atomic, BOOL hasStrong);
WB_EXTERN void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, BOOL shouldCopy);

#define WBSetterCopyAtomic(ivar, var) do { \
  objc_setProperty(self, _cmd, (ptrdiff_t)(&ivar) - (ptrdiff_t)(self), var, YES, 1); \
} while (0)

// Hack, see runtime source (use OBJC_PROPERTY_MUTABLECOPY as shouldCopy arg)
#define WBSetterMutableCopyAtomic(ivar, var) do { \
  objc_setProperty(self, _cmd, (ptrdiff_t)(&ivar) - (ptrdiff_t)(self), var, YES, 2); \
} while (0)

#define WBSetterRetainAtomic(ivar, var) do { \
  objc_setProperty(self, _cmd, (ptrdiff_t)(&ivar) - (ptrdiff_t)(self), var, YES, NO); \
} while (0)

/*!
 @defined WBDelegateHandle
 @abstract Check if delegate implements a method
 @param delegate The Delegate to register.
 @param method	method name
 */
WB_INLINE bool __WBDelegateHandle(id delegate, SEL method) { return delegate && [delegate respondsToSelector:method]; }
#define WBDelegateHandle(delegate, method) __WBDelegateHandle(delegate, @selector(method))

/*!
 @defined WBDelegateRegisterNotification
 @abstract   Used to register a delegate.
 @param		obj	The Delegate to register.
 @param		sel	The selector the notification need called.
 @param		notif The notification name.
 */
#define WBDelegateRegisterNotification(obj, sel, notif)		if ([obj respondsToSelector:sel]) {	\
  																[[NSNotificationCenter defaultCenter] addObserver:obj selector:sel name:notif object:self]; }

#define WBDelegateUnregisterNotification(obj, sel, notif)	if ([obj respondsToSelector:sel]) {	\
  																[[NSNotificationCenter defaultCenter] removeObserver:obj name:notif object:self];	}

/*!
 @defined WBClusterException
 @abstract   Raise an invalig argument exception.
 */
#define WBClusterException()    WBThrowException(NSInvalidArgumentException, \
                                                 @"-%@ only defined for abstract class. Define -[%@ %@]!", \
                                                 NSStringFromSelector(_cmd), NSStringFromClass([self class]), NSStringFromSelector(_cmd))

/*!
 @defined WBCurrentBundle
 @result   Returns the bundle for the caller class.
 */
#define WBCurrentBundle()         [NSBundle bundleForClass:[self class]]
/*!
 @defined WBBundleForClass
 @param	aClass wrapper on bundleForClass:
 @result Returns the bundle for aClass.
 */
#define WBBundleForClass(aClass)  [NSBundle bundleForClass:[aClass class]]

/*
 Usage: 
 WBIndexesIterator(idx, (NSIndexSet *)indexes) {
 }
 */
#define WBIndexesIterator(var, indexes) for (NSUInteger var = [indexes firstIndex]; indexes != nil && var != NSNotFound; var = [indexes indexGreaterThanIndex:var])

#define WBIndexesReverseIterator(var, indexes) for (NSUInteger var = [indexes lastIndex]; indexes != nil && var != NSNotFound; var = [indexes indexLessThanIndex:var])

WB_INLINE
NSIndexSet *WBIndexesForCount(NSUInteger count) { return [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, count)]; }
WB_INLINE
NSIndexSet *WBIndexesForArray(NSArray *anArray) { return WBIndexesForCount([anArray count]); }

#pragma mark -
#pragma mark Cocoa To Foundation converter
WB_INLINE
NSRange NSRangeFromCFRange(CFRange range) {
  return NSMakeRange((NSUInteger)range.location, (NSUInteger)range.length);
}
WB_INLINE
CFRange NSRangeToCFRange(NSRange range) {
  return CFRangeMake((CFIndex)range.location, (CFIndex)range.length);
}

#pragma mark -
#pragma mark NSNumber Wrapper
/* Get NSNumber for a number */
WB_INLINE
NSNumber* WBBool(BOOL value) { return [NSNumber numberWithBool:value]; }

#define WBChar WBInt8
#define WBUChar WBUInt8
#define WBShort WBInt16
#define WBUShort WBUInt16

WB_INLINE
NSNumber* WBInt8(int8_t value) { return [NSNumber numberWithChar:value]; }
WB_INLINE
NSNumber* WBUInt8(uint8_t value) { return [NSNumber numberWithUnsignedChar:value]; }

WB_INLINE
NSNumber* WBInt16(int16_t value) { return [NSNumber numberWithShort:value]; }
WB_INLINE
NSNumber* WBUInt16(uint16_t value) { return [NSNumber numberWithUnsignedShort:value]; }

WB_INLINE
NSNumber* WBInt32(int32_t value) { return [NSNumber numberWithInt:value]; }
WB_INLINE
NSNumber* WBUInt32(uint32_t value) { return [NSNumber numberWithUnsignedInt:value]; }

#if __LP64__
WB_INLINE
NSNumber* WBInt64(int64_t value) { return [NSNumber numberWithLong:value]; }
WB_INLINE
NSNumber* WBUInt64(uint64_t value) { return [NSNumber numberWithUnsignedLong:value]; }
#else
WB_INLINE
NSNumber* WBInt64(int64_t value) { return [NSNumber numberWithLongLong:value]; }
WB_INLINE
NSNumber* WBUInt64(uint64_t value) { return [NSNumber numberWithUnsignedLongLong:value]; }
#endif

#if __LP64__
WB_INLINE
CGFloat WBCGFloatValue(id value) { return value ? [value doubleValue] : 0; }
WB_INLINE
NSNumber* WBCGFloat(CGFloat value) { return [NSNumber numberWithDouble:value]; }
#else
WB_INLINE
CGFloat WBCGFloatValue(id value) { return value ? [value floatValue] : 0; }
WB_INLINE
NSNumber* WBCGFloat(CGFloat value) { return [NSNumber numberWithFloat:value]; }
#endif

WB_INLINE
NSNumber* WBFloat(float value) { return [NSNumber numberWithFloat:value]; }
WB_INLINE
NSNumber* WBDouble(double value) { return [NSNumber numberWithDouble:value]; }

#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
WB_INLINE
NSNumber* WBInteger(NSInteger value) { return [NSNumber numberWithInt:value]; }
WB_INLINE
NSNumber* WBUInteger(NSUInteger value) { return [NSNumber numberWithUnsignedInt:value]; }
#else
WB_INLINE
NSNumber* WBInteger(NSInteger value) { return [NSNumber numberWithInteger:value]; }
WB_INLINE
NSNumber* WBUInteger(NSUInteger value) { return [NSNumber numberWithUnsignedInteger:value]; }
#endif

/* Integer value compatibility */
#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
WB_INLINE
NSInteger WBIntegerValue(id object) { return [object intValue]; }
WB_INLINE
NSUInteger WBUIntegerValue(NSNumber *object) { return [object unsignedIntValue]; }
WB_INLINE
void WBEncodeInteger(NSCoder *coder, NSInteger value, NSString *key) { [coder encodeInt:value forKey:key]; }
WB_INLINE
NSUInteger WBDecodeInteger(NSCoder *coder, NSString *key) { return [coder decodeIntForKey:key]; }
#else
WB_INLINE
NSInteger WBIntegerValue(id object) { return [object integerValue]; }
WB_INLINE
NSUInteger WBUIntegerValue(NSNumber *object) { return [object unsignedIntegerValue]; }
WB_INLINE
void WBEncodeInteger(NSCoder *coder, NSInteger value, NSString *key) { [coder encodeInteger:value forKey:key]; }
WB_INLINE
NSUInteger WBDecodeInteger(NSCoder *coder, NSString *key) { return [coder decodeIntegerForKey:key]; }
#endif

#endif /* __WB_OBJC__ */

// 64 bits to 32 bits safe casts
WB_INLINE
int32_t WBInt64To32(int64_t value) {
  assert(value >= INT32_MIN && value <= INT32_MAX && "Integer overflow");
  return (int32_t)value;
}
WB_INLINE
uint32_t WBUInt64To32(uint64_t value) {
  assert(value <= UINT32_MAX && "Integer overflow");
  return (uint32_t)value;
}

#pragma mark -
#pragma mark Debugging & Profiling

#define WBWaitDebugger() raise(SIGSTOP)

#include <mach/mach.h>
#include <mach/mach_time.h>

typedef uint64_t WBHostTime;

WB_INLINE
WBHostTime WBHostTimeGetCurrent(void) { return mach_absolute_time(); }

WB_INLINE
WBHostTime WBNanoToHostTime(UInt64 nano) {
  return UnsignedWideToUInt64(NanosecondsToAbsolute(UInt64ToUnsignedWide(nano)));
}

WB_INLINE
UInt64 WBHostTimeToNano(WBHostTime delta) {
  // Convert to nanoseconds.
  return UnsignedWideToUInt64(AbsoluteToNanoseconds(UInt64ToUnsignedWide(delta)));
}

WB_INLINE
UInt64 WBHostTimeToMicro(WBHostTime delta) { return llround((double)WBHostTimeToNano(delta) / 1e3); }

WB_INLINE
UInt32 WBHostTimeToMillis(WBHostTime delta) { return (UInt32)lround((double)WBHostTimeToNano(delta) / 1e6); }

WB_INLINE
CFTimeInterval WBHostTimeToTimeInterval(WBHostTime delta) { return (CFTimeInterval)WBHostTimeToNano(delta) / 1e9; }

#endif /* __SHARED_PREFIX_H */
